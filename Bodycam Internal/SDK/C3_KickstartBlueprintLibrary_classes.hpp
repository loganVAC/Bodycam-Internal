#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: C3_KickstartBlueprintLibrary

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "C3_KickstartBlueprintLibrary_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "UMG_structs.hpp"
#include "SlateCore_structs.hpp"


namespace SDK
{

// Class C3_KickstartBlueprintLibrary.C3_KBP_Actor_FL
// 0x0000 (0x0028 - 0x0028)
class UC3_KBP_Actor_FL final : public UBlueprintFunctionLibrary
{
public:
	static double FL_GetHeightFromFloor(class AActor* Target, const TArray<class AActor*>& ActorsToIgnore);
	static bool FL_HasComponent_Class(class AActor* Target, TSubclassOf<class UActorComponent> ComponentClass);
	static void FL_SetActorTickEnabled_Pro(class AActor* TargetActor, bool InEnable, bool IncludeDescendants);
	static bool FL_SnapTo_Core(struct FHitResult* OutHitResult, class AActor* Target, const struct FVector& InTraceStart, const struct FVector& InTraceEnd, const struct FVector& InHalfSize, double StepSize, bool IncludeChildActors);
	static bool FL_SnapToCeiling(class AActor* Target, double MaxDistance, double StepSize, bool IncludeChildActors);
	static bool FL_SnapToFloor(class AActor* Target, double MaxDistance, double StepSize, bool IncludeChildActors);
	static bool FL_SnapToSide(class AActor* Target, EC3_KBP_SnapDirection Direction, double MaxDistance, double StepSize, bool IncludeChildActors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"C3_KBP_Actor_FL">();
	}
	static class UC3_KBP_Actor_FL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UC3_KBP_Actor_FL>();
	}
};
static_assert(alignof(UC3_KBP_Actor_FL) == 0x000008, "Wrong alignment on UC3_KBP_Actor_FL");
static_assert(sizeof(UC3_KBP_Actor_FL) == 0x000028, "Wrong size on UC3_KBP_Actor_FL");

// Class C3_KickstartBlueprintLibrary.C3_KBP_Editor_FL
// 0x0000 (0x0028 - 0x0028)
class UC3_KBP_Editor_FL final : public UBlueprintFunctionLibrary
{
public:
	static void FL_SetEditorScale(const double InScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"C3_KBP_Editor_FL">();
	}
	static class UC3_KBP_Editor_FL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UC3_KBP_Editor_FL>();
	}
};
static_assert(alignof(UC3_KBP_Editor_FL) == 0x000008, "Wrong alignment on UC3_KBP_Editor_FL");
static_assert(sizeof(UC3_KBP_Editor_FL) == 0x000028, "Wrong size on UC3_KBP_Editor_FL");

// Class C3_KickstartBlueprintLibrary.C3_KBP_Editor_UObject
// 0x0000 (0x0028 - 0x0028)
class UC3_KBP_Editor_UObject final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"C3_KBP_Editor_UObject">();
	}
	static class UC3_KBP_Editor_UObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UC3_KBP_Editor_UObject>();
	}
};
static_assert(alignof(UC3_KBP_Editor_UObject) == 0x000008, "Wrong alignment on UC3_KBP_Editor_UObject");
static_assert(sizeof(UC3_KBP_Editor_UObject) == 0x000028, "Wrong size on UC3_KBP_Editor_UObject");

// Class C3_KickstartBlueprintLibrary.C3_KBP_General_FL
// 0x0000 (0x0028 - 0x0028)
class UC3_KBP_General_FL final : public UBlueprintFunctionLibrary
{
public:
	static class AActor* CloneActor(class AActor* InputActor);
	static class AActor* CloneActorPro(class AActor* InputActor, TArray<class AActor*>* OutAttachedActos, bool IncludedAttachedActors, EAttachmentRule InLocationRule, EAttachmentRule InRotationRule, EAttachmentRule InScaleRule, bool bInWeldSimulatedBodies);
	static bool FL_CallFunctionByName(class UObject* TargetObject, const class FString& FunctionName);
	static struct FLinearColor FL_Convert_RGBV_RGB(const struct FLinearColor& RGB, float HSV_V);
	static int32 FL_CSV_GetCSVTargetIndexFromDataArray(int32 TargetRowIndex, int32 ColumnCountLength, int32 TargetColumnIndex);
	static void FL_DateTimeToString(const struct FDateTime& InDateTime, class FString* OutStringFullYr1, class FString* OutStringFullYr2, class FString* OutStringYearMonth1, class FString* OutStringYearMonth2, class FString* OutStringMonthDay1, class FString* OutStringMonthDay2, class FString* OutStringYear, class FString* OutStringMonth, class FString* OutStringDay, class FString* OutStringHourMinSecondMilli, class FString* OutStringHourMinSecond1, class FString* OutStringHourMin1, class FString* OutStringHour1, const class FString& Separator);
	static void FL_Delay_RandomTime(class UObject* WorldContextObject, double Min, double Max);
	static void FL_DeltaTransform(const class UObject* WorldContextObject, const struct FTransform& A_Transform, const struct FTransform& B_Transform, struct FTransform* DeltaTransform);
	static struct FVector FL_DirectionIntToVector(int32 DirectionInt, double Multiplier);
	static void FL_FindNeighbor_Int(int32 Value, const TArray<int32>& Array, bool* HasTheSameValue, int32* SameValue, int32* SameIndex, bool* HasSmallerValue, int32* SmallerNeighbor, int32* SmallerIndex, bool* HasLargerValue, int32* LargerNeighbor, int32* LargerIndex);
	static bool FL_Float_IsInteger(double InFloat);
	static bool FL_GetAllDataTables(const class FString& SpecificNameKeyword, TArray<class UDataTable*>* AllDataTables, TArray<struct FAssetData>* AllAssetData);
	static void FL_GetCurrentFPS(const class UObject* WorldContextObject, float* FPS, int32* FPS_Rounded, class FString* FPS_RoundedString, class FText* FPS_RoundedText);
	static struct FDateTime FL_GetCurrentTime();
	static void FL_GetProjectVersion(const class UObject* WorldContextObject, class FString* Version);
	static int32 FL_Int_Increment_Ceiling(int32 Source, int32 Max);
	static int32 FL_Int_Increment_Cycle(int32 Source, int32 Min, int32 Max);
	static bool FL_IsValidColorHex_RGB(const class FString& InString, class FString* Result);
	static bool FL_IsValidColorHex_RGBA(const class FString& InString, class FString* Result);
	static struct FDateTime FL_MakeDateTime_Pro(int32 Year, int32 Month, int32 Day, const int32 Hour, const int32 Minute, const int32 Second, const int32 Millisecond);
	static TMap<class AActor*, float> FL_MapSort_ActorFloat_Value(const TMap<class AActor*, float>& Source, bool Ascending);
	static TMap<class AActor*, class FText> FL_MapSort_ActorText_Value(const TMap<class AActor*, class FText>& Source, bool Ascending);
	static void FL_NegateTransform(const class UObject* WorldContextObject, const struct FTransform& InTransform, struct FTransform* OutTransform);
	static void FL_PrintString_Lite(const class UObject* WorldContextObject, const class FString& InString, EC3_KBP_PrintColor Color);
	static void FL_PrintString_Pro(const class UObject* WorldContextObject, const class FString& String1, const class FString& String2, const class FString& String3, const class FString& String4, EC3_KBP_PrintColor Color);
	static class FString FL_RandomString(const class FString& ValidChars, int32 NumChars);
	static class FString FL_RandomString_Pro(int32 NumChars, bool UpperLetters, bool LowerLetters, bool Numbers);
	static void FL_SetActive(class AActor* TargetActor, bool NewActive, bool IncludeAttachedActors);
	static void FL_SetMaxFPS(const class UObject* WorldContextObject, const double InMaxFPS);
	static void FL_SetNearClipPlane(class UObject* WorldContextObject, const class FString& Distance);
	static void FL_SM_SetMaterials(class UPrimitiveComponent* Target, const TArray<class UMaterialInterface*>& Materials);
	static void FL_StringRemoveAt(const class FString& Source, int32 StartIndex, class FString* OutString, int32 Count);
	static bool FL_Vector2D_InRange(const struct FVector2D& Source, const struct FVector2D& Begin, const struct FVector2D& End, bool InclusiveMin, bool InclusiveMax);
	static struct FVector FL_Vector_Multiply_Float(const struct FVector& InVector, double InFloat);
	static void FL_Viewport_Lit(class UObject* WorldContextObject);
	static void FL_Viewport_Unlit(class UObject* WorldContextObject);
	static bool FL_VR_IsEnable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"C3_KBP_General_FL">();
	}
	static class UC3_KBP_General_FL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UC3_KBP_General_FL>();
	}
};
static_assert(alignof(UC3_KBP_General_FL) == 0x000008, "Wrong alignment on UC3_KBP_General_FL");
static_assert(sizeof(UC3_KBP_General_FL) == 0x000028, "Wrong size on UC3_KBP_General_FL");

// Class C3_KickstartBlueprintLibrary.C3_KBP_WidgetCommon
// 0x0000 (0x0028 - 0x0028)
class IC3_KBP_WidgetCommon final : public IInterface
{
public:
	bool GetIsHovered();
	void OnVisibilityUpdate(bool NewVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"C3_KBP_WidgetCommon">();
	}
	static class IC3_KBP_WidgetCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<IC3_KBP_WidgetCommon>();
	}
};
static_assert(alignof(IC3_KBP_WidgetCommon) == 0x000008, "Wrong alignment on IC3_KBP_WidgetCommon");
static_assert(sizeof(IC3_KBP_WidgetCommon) == 0x000028, "Wrong size on IC3_KBP_WidgetCommon");

// Class C3_KickstartBlueprintLibrary.C3_KBP_Paks_FL
// 0x0000 (0x0028 - 0x0028)
class UC3_KBP_Paks_FL final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class FString> GetPakContentList(const class FString& PakFilename, const bool bOnlyCooked);
	static class UClass* LoadAssetAsClass(const class FString& PakContentPath);
	static class FName LoadAssetAsLevelName(const class FString& PakContentPath);
	static bool MountAndRegisterPak(const class FString& PakFilename);
	static bool UnmountPakFile(const class FString& PakFilename);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"C3_KBP_Paks_FL">();
	}
	static class UC3_KBP_Paks_FL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UC3_KBP_Paks_FL>();
	}
};
static_assert(alignof(UC3_KBP_Paks_FL) == 0x000008, "Wrong alignment on UC3_KBP_Paks_FL");
static_assert(sizeof(UC3_KBP_Paks_FL) == 0x000028, "Wrong size on UC3_KBP_Paks_FL");

// Class C3_KickstartBlueprintLibrary.C3_KBP_Rendering_FL
// 0x0000 (0x0028 - 0x0028)
class UC3_KBP_Rendering_FL final : public UBlueprintFunctionLibrary
{
public:
	static void FL_Set_RTX_ISM_Count(const class UObject* WorldContextObject, int32 NewCount);
	static void FL_Set_RTX_ISM_Radius(const class UObject* WorldContextObject, double NewCount);
	static void FL_Set_RTX_ISM_WPO_Enable(const class UObject* WorldContextObject, bool NewEnable);
	static void FL_VirtualShadowMap_HidePoolStat(class UObject* WorldContextObject);
	static void FL_VirtualShadowMap_SetPoolSize(class UObject* WorldContextObject, int32 InPoolSize);
	static void FL_VirtualShadowMap_ShowPoolStat(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"C3_KBP_Rendering_FL">();
	}
	static class UC3_KBP_Rendering_FL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UC3_KBP_Rendering_FL>();
	}
};
static_assert(alignof(UC3_KBP_Rendering_FL) == 0x000008, "Wrong alignment on UC3_KBP_Rendering_FL");
static_assert(sizeof(UC3_KBP_Rendering_FL) == 0x000028, "Wrong size on UC3_KBP_Rendering_FL");

// Class C3_KickstartBlueprintLibrary.C3_KBP_Struct_FL
// 0x0000 (0x0028 - 0x0028)
class UC3_KBP_Struct_FL final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class AActor*> FL_Array_CastTo_Actor(const TArray<class AActor*>& InArray, TSubclassOf<class AActor> ActorClass, bool ExactClassOnly);
	static TArray<class UObject*> FL_Array_CastTo_Object(const TArray<class UObject*>& InArray, TSubclassOf<class UObject> ObjectClass, bool ExactClassOnly);
	static TArray<class UWidget*> FL_Array_CastTo_Widget(const TArray<class UWidget*>& InArray, TSubclassOf<class UWidget> WidgetClass, bool ExactClassOnly);
	static TArray<class FName> FL_Array_Divide_Name(const TArray<class FName>& Source, int32 Divisor, int32 ReturnSection);
	static TArray<class FString> FL_Array_Divide_String(const TArray<class FString>& Source, int32 Divisor, int32 ReturnSection);
	static void FL_Array_Print_Bool(const class UObject* WorldContextObject, const TArray<bool>& Input_Array);
	static void FL_Array_Print_Byte(const class UObject* WorldContextObject, const TArray<uint8>& Input_Array);
	static void FL_Array_Print_EasingFuncArray(const class UObject* WorldContextObject, const TArray<EEasingFunc>& Input_Array);
	static void FL_Array_Print_Float(const class UObject* WorldContextObject, const TArray<float>& Input_Array);
	static void FL_Array_Print_GenericTypeArray(const class UObject* WorldContextObject, const struct FAllGenericTypeArray& Input_Array);
	static void FL_Array_Print_Int(const class UObject* WorldContextObject, const TArray<int32>& Input_Array);
	static void FL_Array_Print_LinearColor(const class UObject* WorldContextObject, const TArray<struct FLinearColor>& Input_Array);
	static void FL_Array_Print_Name(const class UObject* WorldContextObject, const TArray<class FName>& Input_Array);
	static void FL_Array_Print_Object(const class UObject* WorldContextObject, const TArray<class UObject*>& Input_Array);
	static void FL_Array_Print_Rotator(const class UObject* WorldContextObject, const TArray<struct FRotator>& Input_Array);
	static void FL_Array_Print_String(const class UObject* WorldContextObject, const TArray<class FString>& Input_Array);
	static void FL_Array_Print_Text(const class UObject* WorldContextObject, const TArray<class FText>& Input_Array);
	static void FL_Array_Print_Transform(const class UObject* WorldContextObject, const TArray<struct FTransform>& Input_Array);
	static void FL_Array_Print_Vector(const class UObject* WorldContextObject, const TArray<struct FVector>& Input_Array);
	static void FL_Array_Print_Vector2D(const class UObject* WorldContextObject, const TArray<struct FVector2D>& Input_Array);
	static class FString FL_IntToStringMinimumDigits(int32 Source, int32 MinDigits);
	static TMap<int32, bool> FL_Map_Append_IntBool(const TMap<int32, bool>& Map_A, const TMap<int32, bool>& Map_B);
	static TMap<int32, EEasingFunc> FL_Map_Append_IntEasingFunc(const TMap<int32, EEasingFunc>& Map_A, const TMap<int32, EEasingFunc>& Map_B);
	static TMap<int32, double> FL_Map_Append_IntFloat(const TMap<int32, double>& Map_A, const TMap<int32, double>& Map_B);
	static TMap<int32, class UObject*> FL_Map_Append_IntObject(const TMap<int32, class UObject*>& Map_A, const TMap<int32, class UObject*>& Map_B);
	static TMap<int32, struct FRotator> FL_Map_Append_IntRotator(const TMap<int32, struct FRotator>& Map_A, const TMap<int32, struct FRotator>& Map_B);
	static TMap<int32, class FText> FL_Map_Append_IntText(const TMap<int32, class FText>& Map_A, const TMap<int32, class FText>& Map_B);
	static TMap<int32, struct FVector> FL_Map_Append_IntVector(const TMap<int32, struct FVector>& Map_A, const TMap<int32, struct FVector>& Map_B);
	static TMap<int32, bool> FL_Map_MakeByArray_IntBool(const TArray<int32>& Input_Key, const TArray<bool>& Input_Value);
	static TMap<int32, EEasingFunc> FL_Map_MakeByArray_IntEasingFunc(const TArray<int32>& Input_Key, const TArray<EEasingFunc>& Input_Value);
	static TMap<int32, double> FL_Map_MakeByArray_IntFloat(const TArray<int32>& Input_Key, const TArray<double>& Input_Value);
	static TMap<int32, class UObject*> FL_Map_MakeByArray_IntObject(const TArray<int32>& Input_Key, const TArray<class UObject*>& Input_Value);
	static TMap<int32, struct FRotator> FL_Map_MakeByArray_IntRotator(const TArray<int32>& Input_Key, const TArray<struct FRotator>& Input_Value);
	static TMap<int32, class FText> FL_Map_MakeByArray_IntText(const TArray<int32>& Input_Key, const TArray<class FText>& Input_Value);
	static TMap<int32, struct FVector> FL_Map_MakeByArray_IntVector(const TArray<int32>& Input_Key, const TArray<struct FVector>& Input_Value);
	static TMap<int32, bool> FL_MapSort_IntBool_Key(const TMap<int32, bool>& Source, bool Ascending);
	static TMap<int32, uint8> FL_MapSort_IntByte_Key(const TMap<int32, uint8>& Source, bool Ascending);
	static TMap<int32, EEasingFunc> FL_MapSort_IntEasingFunc_Key(const TMap<int32, EEasingFunc>& Source, bool Ascending);
	static TMap<int32, float> FL_MapSort_IntFloat_Key(const TMap<int32, float>& Source, bool Ascending);
	static TMap<int32, int32> FL_MapSort_IntInt_Key(const TMap<int32, int32>& Source, bool Ascending);
	static TMap<int32, class FName> FL_MapSort_IntName_Key(const TMap<int32, class FName>& Source, bool Ascending);
	static TMap<int32, class UObject*> FL_MapSort_IntObject_Key(const TMap<int32, class UObject*>& Source, bool Ascending);
	static TMap<int32, struct FRotator> FL_MapSort_IntRotator_Key(const TMap<int32, struct FRotator>& Source, bool Ascending);
	static TMap<int32, class FString> FL_MapSort_IntString_Key(const TMap<int32, class FString>& Source, bool Ascending);
	static TMap<int32, class FText> FL_MapSort_IntText_Key(const TMap<int32, class FText>& Source, bool Ascending);
	static TMap<int32, struct FTransform> FL_MapSort_IntTransform_Key(const TMap<int32, struct FTransform>& Source, bool Ascending);
	static TMap<int32, struct FVector> FL_MapSort_IntVector_Key(const TMap<int32, struct FVector>& Source, bool Ascending);
	static class FString FL_PrintEnumAsString();
	static struct FAllGenericTypeArray FL_RemoveAllArrayByIndex(const struct FAllGenericTypeArray& Source, int32 RemoveIndex);
	static bool FL_StringEqualExactly_3Pairs(const class FString& A1, const class FString& A2, const class FString& A3, const class FString& B1, const class FString& B2, const class FString& B3);
	static class FString FL_ToValidFileName(const class FString& Source, const class FString& ReplaceChar);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"C3_KBP_Struct_FL">();
	}
	static class UC3_KBP_Struct_FL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UC3_KBP_Struct_FL>();
	}
};
static_assert(alignof(UC3_KBP_Struct_FL) == 0x000008, "Wrong alignment on UC3_KBP_Struct_FL");
static_assert(sizeof(UC3_KBP_Struct_FL) == 0x000028, "Wrong size on UC3_KBP_Struct_FL");

// Class C3_KickstartBlueprintLibrary.C3_KBP_Widget_FL
// 0x0000 (0x0028 - 0x0028)
class UC3_KBP_Widget_FL final : public UBlueprintFunctionLibrary
{
public:
	static float FL_GetScrollValue(class UScrollBox* ScrollBox);
	static void FL_ImplementRecentHoveredPool(class UWidget* TargetWidget, TArray<bool>& Pool, const bool AdditionalCondition, int32 PoolSize);
	static float FL_SetScrollValue(class UScrollBox* ScrollBox, float Value);
	static void FL_SetVisibilityPro(class UWidget* Target, ESlateVisibility InVisibility);
	static bool FL_Textbox_IsValidCommit(ETextCommit Method);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"C3_KBP_Widget_FL">();
	}
	static class UC3_KBP_Widget_FL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UC3_KBP_Widget_FL>();
	}
};
static_assert(alignof(UC3_KBP_Widget_FL) == 0x000008, "Wrong alignment on UC3_KBP_Widget_FL");
static_assert(sizeof(UC3_KBP_Widget_FL) == 0x000028, "Wrong size on UC3_KBP_Widget_FL");

}

