#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Inventory

#include "Basic.hpp"

#include "STR_Actor_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameMode_structs.hpp"
#include "E_Team_structs.hpp"
#include "ALS_OverlayState_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass Inventory.Inventory_C
// 0x0070 (0x0110 - 0x00A0)
class UInventory_C final : public UActorComponent
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x00A0(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	TArray<class AActor*>                         InventorySlots;                                    // 0x00A8(0x0010)(Edit, BlueprintVisible, Net, DisableEditOnTemplate)
	int32                                         MaxSlots;                                          // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AALS_AnimMan_CharacterBP_C*             Owner;                                             // 0x00C0(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	int32                                         Current_Index_Equiped;                             // 0x00C8(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         New_Index_Equiped;                                 // 0x00CC(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class UClass*>                         Default;                                           // 0x00D0(0x0010)(Edit, BlueprintVisible, Net)
	bool                                          WheelBlocking;                                     // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 NextActorEquiped;                                  // 0x00E8(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	bool                                          WheelStillSpinning;                                // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSTR_Actor>                     StarterWeapons;                                    // 0x00F8(0x0010)(Edit, BlueprintVisible, Net, DisableEditOnInstance)
	bool                                          IsSwapping;                                        // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EGameMode                                     Game_Mode;                                         // 0x0109(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void AddWep(class UClass* Class_0);
	void ClearEmptySlot();
	void Death__Server_();
	void DefineFinalStarterWeapons();
	void Equip(class AActor* Actor);
	void Equip__Client_();
	void Equip__Server_();
	void ExecuteUbergraph_Inventory(int32 EntryPoint);
	void GetNewIndexEquiped(int32 Index_0, int32* NewIndex);
	void HandleItem(class AActor** Handle_Actor);
	void IndexEmpty(int32* Array_Index);
	void InpActEvt_IA_Slot1_K2Node_EnhancedInputActionEvent_5(const struct FInputActionValue& ActionValue, float ElapsedTime, float TriggeredTime, const class UInputAction* SourceAction);
	void InpActEvt_IA_Slot2_K2Node_EnhancedInputActionEvent_4(const struct FInputActionValue& ActionValue, float ElapsedTime, float TriggeredTime, const class UInputAction* SourceAction);
	void InpActEvt_IA_Slot3_K2Node_EnhancedInputActionEvent_3(const struct FInputActionValue& ActionValue, float ElapsedTime, float TriggeredTime, const class UInputAction* SourceAction);
	void InpActEvt_IA_Slot4_K2Node_EnhancedInputActionEvent_2(const struct FInputActionValue& ActionValue, float ElapsedTime, float TriggeredTime, const class UInputAction* SourceAction);
	void InpActEvt_IA_Slot5_K2Node_EnhancedInputActionEvent_1(const struct FInputActionValue& ActionValue, float ElapsedTime, float TriggeredTime, const class UInputAction* SourceAction);
	void InpActEvt_IA_Slot6_K2Node_EnhancedInputActionEvent_0(const struct FInputActionValue& ActionValue, float ElapsedTime, float TriggeredTime, const class UInputAction* SourceAction);
	void Inventory_Organization();
	void InventoryFull(bool* Full_);
	void IsBomber(bool* IsTheBomber);
	void IsValidIndex(int32 Input);
	void IsValidItemTeam(E_Team ItemTeam, bool* Return);
	void ReceiveBeginPlay();
	void Remove_To_Inventory__Server_(class AActor* Actor_To_Remove);
	void Spawn_Default__Inventory_();
	void Spawn_Default_client__Inventory_();
	void SpawnBomb__Server_();
	void SpawnSounds__Multicast_(class USoundBase* Sound, float VolumeMultiplier);
	void SwapToSpecificActor(class AActor* Actor);
	void Switch__client_(int32 New_Value);
	void Switch__Server_(class AActor* Actor, bool PassSecurity);
	void Try_Add_To_inventory__Server_(class AActor* New_Actor);
	void Try_Drop__Server_();
	void UnEquip();
	void UnEquip__Client_();
	void UnEquip__Server_();
	void UpdateOverlay(class AActor* Actor_Picked);
	void VisualAttach(class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"Inventory_C">();
	}
	static class UInventory_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventory_C>();
	}
};
static_assert(alignof(UInventory_C) == 0x000008, "Wrong alignment on UInventory_C");
static_assert(sizeof(UInventory_C) == 0x000110, "Wrong size on UInventory_C");
static_assert(offsetof(UInventory_C, UberGraphFrame) == 0x0000A0, "Member 'UInventory_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(UInventory_C, InventorySlots) == 0x0000A8, "Member 'UInventory_C::InventorySlots' has a wrong offset!");
static_assert(offsetof(UInventory_C, MaxSlots) == 0x0000B8, "Member 'UInventory_C::MaxSlots' has a wrong offset!");
static_assert(offsetof(UInventory_C, Owner) == 0x0000C0, "Member 'UInventory_C::Owner' has a wrong offset!");
static_assert(offsetof(UInventory_C, Current_Index_Equiped) == 0x0000C8, "Member 'UInventory_C::Current_Index_Equiped' has a wrong offset!");
static_assert(offsetof(UInventory_C, New_Index_Equiped) == 0x0000CC, "Member 'UInventory_C::New_Index_Equiped' has a wrong offset!");
static_assert(offsetof(UInventory_C, Default) == 0x0000D0, "Member 'UInventory_C::Default' has a wrong offset!");
static_assert(offsetof(UInventory_C, WheelBlocking) == 0x0000E0, "Member 'UInventory_C::WheelBlocking' has a wrong offset!");
static_assert(offsetof(UInventory_C, NextActorEquiped) == 0x0000E8, "Member 'UInventory_C::NextActorEquiped' has a wrong offset!");
static_assert(offsetof(UInventory_C, WheelStillSpinning) == 0x0000F0, "Member 'UInventory_C::WheelStillSpinning' has a wrong offset!");
static_assert(offsetof(UInventory_C, StarterWeapons) == 0x0000F8, "Member 'UInventory_C::StarterWeapons' has a wrong offset!");
static_assert(offsetof(UInventory_C, IsSwapping) == 0x000108, "Member 'UInventory_C::IsSwapping' has a wrong offset!");
static_assert(offsetof(UInventory_C, Game_Mode) == 0x000109, "Member 'UInventory_C::Game_Mode' has a wrong offset!");

}

